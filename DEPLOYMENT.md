# Deployment Guide - Render.com

## Architecture

The application uses a multi-service architecture on Render:
- **Backend**: Spring Boot application (Docker)
- **Frontend**: Next.js application (Docker)
- **Database**: PostgreSQL (Render managed)

## Database Configuration

Render provides database connection details via environment variables:
- `DB_HOST`: Database host
- `DB_PORT`: Database port
- `DB_NAME`: Database name
- `SPRING_DATASOURCE_USERNAME`: Database user
- `SPRING_DATASOURCE_PASSWORD`: Database password

The startup script (`backend/start.sh`) constructs the JDBC URL from these components:
```
jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=require
```

## Memory Configuration

For Render's free tier (512MB RAM):
- **Heap**: 256MB-450MB (`-Xms256m -Xmx450m`)
- **GC**: G1GC with optimizations
- **Connection Pool**: Max 5 connections (reduced from default 10)

## Health Checks

The backend exposes health check endpoint at `/actuator/health`:
- Checked every 30 seconds
- Includes database connectivity status
- Must respond within timeout or service restarts

## Common Issues & Solutions

### 1. Database Connection Errors

**Problem**: `'url' must start with "jdbc"`
**Solution**: Ensure `render.yaml` uses individual DB properties (host, port, database) not connectionString

### 2. Out of Memory Errors

**Problem**: Application crashes with OOM
**Solution**: Memory limits are set in `start.sh`. For persistent issues, consider:
- Upgrading to paid tier
- Reducing connection pool size
- Optimizing queries

### 3. Slow Startup

**Problem**: Health check fails during deployment
**Solution**: Health check interval is 30s. Spring Boot startup typically takes 15-25s on free tier.

### 4. Database Pool Exhausted

**Problem**: Too many connections
**Solution**: HikariCP settings in `application.properties`:
- Production: max-pool-size=5 (free tier)
- Local: max-pool-size=10

## Environment Variables

### Required (Backend)
- `DB_HOST`, `DB_PORT`, `DB_NAME` - From Render database
- `SPRING_DATASOURCE_USERNAME`, `SPRING_DATASOURCE_PASSWORD` - From Render database
- `JWT_SECRET` - Auto-generated by Render
- `JWT_EXPIRATION` - Default: 86400000 (24h)
- `UPLOAD_PATH` - Default: /app/uploads
- `ALLOWED_ORIGINS` - Frontend URL

### Required (Frontend)
- `NEXT_PUBLIC_API_URL` - Backend URL
- `NODE_ENV` - production

## Deployment Process

1. **Push to GitHub**: Render auto-deploys on push to main branch
2. **Build Phase**: 
   - Backend: Maven builds JAR
   - Frontend: Next.js builds static assets
3. **Deploy Phase**:
   - Docker containers start
   - Health checks begin
   - Traffic routes after successful health check

## Monitoring

Check logs via Render dashboard:
```bash
# Startup logs show:
=== Application Startup ===
Java version: ...
Database configuration:
  Host: ...
  Port: ...
  Database: ...
```

## Local Development

To test the startup script locally:
```bash
export DB_HOST=localhost
export DB_PORT=5432
export DB_NAME=corrigeaqui
export SPRING_DATASOURCE_USERNAME=postgres
export SPRING_DATASOURCE_PASSWORD=postgres

./backend/start.sh
```

## Troubleshooting Commands

```bash
# Check environment variables in Render shell
env | grep -E '^(DB_|SPRING_)'

# Test database connection
psql $DATABASE_URL

# Check Java memory
java -XX:+PrintFlagsFinal -version | grep -i heap
```

## Performance Tips

1. **Database Queries**: Enable query logging temporarily to find slow queries
2. **Connection Pool**: Monitor HikariCP metrics via actuator
3. **Memory**: Check heap usage: `/actuator/metrics/jvm.memory.used`
4. **GC**: Monitor garbage collection frequency

## Security Checklist

- ✅ Database connections use SSL (`sslmode=require`)
- ✅ JWT secret auto-generated per environment
- ✅ CORS configured for specific frontend origin
- ✅ Actuator endpoints limited to health/info
- ✅ Sensitive data via environment variables (not hardcoded)

## Cost Optimization

Free tier limitations:
- Services sleep after 15 minutes of inactivity
- First request after sleep takes ~30s (cold start)
- 512MB RAM limit
- Shared CPU

Recommendations:
- Keep connection pool small (5 connections)
- Optimize startup time
- Consider paid tier for production workloads
